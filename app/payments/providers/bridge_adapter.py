"""
Bridge provider adapter for Python services.

This module provides a compatibility layer that allows Python services to use
the TypeScript Stargate bridge provider implementation.
"""

import os
import json
import logging
import subprocess
import uuid
from datetime import datetime
from typing import Dict, Any, Optional

from .base import BridgeProvider

logger = logging.getLogger(__name__)

class StargateAdapter(BridgeProvider):
    """
    Adapter for the Stargate TypeScript implementation.
    
    This adapter uses Node.js to execute the TypeScript bridge provider functions.
    """
    
    def __init__(self):
        """Initialize the Stargate adapter."""
        self.node_path = os.getenv("NODE_PATH", "node")
        self.script_path = os.path.join(os.path.dirname(__file__), "../../scripts/bridge_proxy.js")
        
        # Ensure the Node.js script exists
        if not os.path.exists(self.script_path):
            self._create_bridge_proxy_script()
    
    def _create_bridge_proxy_script(self):
        """Create a Node.js script that acts as a proxy to the TypeScript implementation."""
        script_dir = os.path.dirname(self.script_path)
        os.makedirs(script_dir, exist_ok=True)
        
        with open(self.script_path, "w") as f:
            f.write("""
// Bridge proxy script - DO NOT EDIT
// This file is automatically generated and allows Python code to call TypeScript implementations

const { getBridgeProvider } = require('../payments/providers/factory');

async function main() {
    const action = process.argv[2];
    const params = JSON.parse(process.argv[3]);
    
    try {
        const bridge = getBridgeProvider();
        let result;
        
        if (action === 'onramp') {
            result = await bridge.onramp(
                params.amount,
                params.currency,
                params.srcChain,
                params.dstChain,
                params.recipient
            );
        } else if (action === 'offramp') {
            result = await bridge.offramp(
                params.amount,
                params.currency,
                params.chain,
                params.bankAccountId
            );
        } else {
            throw new Error(`Unknown action: ${action}`);
        }
        
        console.log(JSON.stringify(result));
        process.exit(0);
    } catch (error) {
        console.error(JSON.stringify({
            error: error.message || 'Unknown error',
            stack: error.stack
        }));
        process.exit(1);
    }
}

main().catch(error => {
    console.error(JSON.stringify({
        error: error.message || 'Unknown error',
        stack: error.stack
    }));
    process.exit(1);
});
""")

    async def _execute_node_script(self, action: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the Node.js bridge proxy script.
        
        Args:
            action: The action to perform (onramp or offramp)
            params: The parameters for the action
            
        Returns:
            The result of the action
            
        Raises:
            ValueError: If the script execution fails
        """
        # Skip execution in test mode and return mock results
        if os.getenv("TESTING") == "1":
            logger.info(f"TESTING mode - mocking Stargate {action} operation")
            return self._get_mock_result(action)
            
        cmd = [self.node_path, self.script_path, action, json.dumps(params)]
        
        try:
            # Use subprocess to execute the Node.js script
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            stdout, stderr = process.communicate()
            
            if process.returncode != 0:
                error_data = json.loads(stderr)
                raise ValueError(f"Bridge operation failed: {error_data.get('error', 'Unknown error')}")
            
            # Parse the result
            return json.loads(stdout)
        except Exception as e:
            logger.error(f"Failed to execute bridge operation: {str(e)}")
            raise ValueError(f"Failed to execute bridge operation: {str(e)}")
    
    def _get_mock_result(self, action: str) -> Dict[str, Any]:
        """Get a mock result for test mode."""
        tx_id = f"stargate_{action}_{uuid.uuid4().hex[:8]}"
        return {
            "tx_id": tx_id,
            "status": "completed",
            "settled_at": datetime.now().isoformat()
        }

    async def onramp(
        self,
        amount: float,
        currency: str,
        src_chain: str,
        dst_chain: str,
        recipient: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Bridge tokens from source chain to destination chain.
        
        Args:
            amount: The amount to bridge
            currency: The currency to use
            src_chain: Source chain ID
            dst_chain: Destination chain ID
            recipient: Recipient address
            metadata: Optional additional metadata
            
        Returns:
            A dictionary with the transaction ID and status
        """
        params = {
            "amount": amount,
            "currency": currency,
            "srcChain": src_chain,
            "dstChain": dst_chain,
            "recipient": recipient,
            "metadata": metadata or {}
        }
        
        result = await self._execute_node_script("onramp", params)
        
        # Convert the result to the expected format
        return {
            "tx_id": result.get("tx_id"),
            "status": result.get("status"),
            "settled_at": result.get("settled_at")
        }

    async def offramp(
        self,
        amount: float,
        currency: str,
        chain: str,
        bank_account_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Offramp tokens to fiat.
        
        Args:
            amount: The amount to offramp
            currency: The currency to use
            chain: The chain ID where the tokens are
            bank_account_id: The bank account to send fiat to
            metadata: Optional additional metadata
            
        Returns:
            A dictionary with the transaction ID and status
        """
        params = {
            "amount": amount,
            "currency": currency,
            "chain": chain,
            "bankAccountId": bank_account_id,
            "metadata": metadata or {}
        }
        
        result = await self._execute_node_script("offramp", params)
        
        # Convert the result to the expected format
        return {
            "tx_id": result.get("tx_id"),
            "status": result.get("status"),
            "settled_at": result.get("settled_at")
        }

# Make the adapter available for import
def get_bridge_provider() -> BridgeProvider:
    """
    Get a bridge provider instance.
    
    Returns:
        An instance of BridgeProvider that uses the Stargate implementation
    """
    return StargateAdapter() 